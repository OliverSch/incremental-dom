{"version":3,"file":"incremental-dom.js","sources":["src/util.js","src/node_data.js","src/nodes.js","src/assertions.js","src/dom_util.js","src/core.js","src/symbols.js","src/attributes.js","src/virtual_elements.js"],"sourcesContent":["/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return new Blank();\n};\n\n\n/**\n * Truncates an array, removing items up until length.\n * @param {!Array<*>} arr The array to truncate.\n * @param {number} length The new length of the array.\n */\nconst truncateArray = function(arr, length) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n};\n\n\n/** */\nexport {\n  createMap,\n  has,\n  truncateArray\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types';\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {NameOrCtorDef} nameOrCtor\n * @param {?string=} key\n * @param {*=} typeId\n * @constructor\n */\nfunction NodeData(nameOrCtor, key, typeId) {\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The nodeName or contructor for the Node.\n   * @const {NameOrCtorDef}\n   */\n  this.nameOrCtor = nameOrCtor;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n\n  /**\n   * @const\n   */\n  this.typeId = typeId;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {NameOrCtorDef} nameOrCtor The nodeName or constructor for the Node.\n * @param {?string=} key The key that identifies the node.\n * @param {*=} typeId The type identifier for the Node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nameOrCtor, key, typeId) {\n  const data = new NodeData(nameOrCtor, key, typeId);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nconst importNode = function(node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  const isElement = node.nodeType === 1;\n  const nodeName = isElement ? node.localName : node.nodeName;\n  const key = isElement ? node.getAttribute('key') : null;\n  const typeId = node['typeId'];\n  const data = initData(node, nodeName, key, typeId);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    const attributes = node.attributes;\n    const attrsArr = data.attrsArr;\n\n    for (let i = 0; i < attributes.length; i += 1) {\n      const attr = attributes[i];\n      const name = attr.name;\n      const value = attr.value;\n\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n\n/** */\nexport {\n  getData,\n  initData,\n  importNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types';\nimport {\n    getData,\n    initData\n} from './node_data';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nameOrCtor === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {*=} typeId The type identifier for the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, nameOrCtor, key, typeId) {\n  let el;\n\n  if (typeof nameOrCtor === 'function') {\n    el = new nameOrCtor();\n  } else {\n    const namespace = getNamespaceForTag(nameOrCtor, parent);\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, nameOrCtor);\n    } else {\n      el = doc.createElement(nameOrCtor);\n    }\n  }\n\n  initData(el, nameOrCtor, key, typeId);\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types';\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nlet inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nconst assertInPatch = function(functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nconst assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nconst assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nconst assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nconst assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nconst assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {NameOrCtorDef} currentNameOrCtor\n  * @param {NameOrCtorDef} nameOrCtor\n  */\nconst assertCloseMatchesOpenTag = function(currentNameOrCtor, nameOrCtor) {\n  if (currentNameOrCtor !== nameOrCtor) {\n    throw new Error('Received a call to close \"' + nameOrCtor + '\" but \"' +\n        currentNameOrCtor + '\" was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nconst assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nconst assertPatchElementNoExtras = function(\n    startNode,\n    currentNode,\n    expectedNextNode,\n    expectedPrevNode) {\n  const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInAttributes = function(value) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInSkip = function(value) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nconst isDocumentRoot = function(node) {\n  return node.nodeType === 11 || node.nodeType === 9;\n};\n\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nconst getAncestry = function(node, root) {\n  const ancestry = [];\n  let cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n\n/**\n * @return {!Node} The root node of the DOM tree that contains this node.\n * @this Node\n */\nconst getRootNode = Node.prototype.getRootNode || function() {\n  let cur = this;\n  let prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nconst getActiveElement = function(node) {\n  const root = getRootNode.call(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nconst getFocusedPath = function(node, root) {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nconst moveBefore = function(parentNode, node, referenceNode) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n\n/** */\nexport {\n  getFocusedPath,\n  moveBefore\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types';\nimport {\n  createElement,\n  createText\n} from './nodes';\nimport { getData } from './node_data';\nimport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport {\n  getFocusedPath,\n  moveBefore\n} from './dom_util';\n\n\n/** @type {?Node} */\nlet currentNode = null;\n\n/** @type {?Node} */\nlet currentParent = null;\n\n/** @type {?Document} */\nlet doc = null;\n\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nconst markFocused = function(focusPath, focused) {\n  for (let i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nconst patchFactory = function(run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  const f = function(node, fn, data) {\n    const prevDoc = doc;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    const focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    const retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Documen to patch.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nconst patchInner = patchFactory(function(node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM. This should have at most one top level element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nconst patchOuter = patchFactory(function(node, fn, data) {\n  let startNode = /** @type {!Element} */({ nextSibling: node });\n  let expectedNextNode = null;\n  let expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode,\n        expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return (startNode === currentNode) ? null : currentNode;\n});\n\n\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {NameOrCtorDef} nameOrCtor The name or constructor to check for.\n * @param {?string=} key An optional key that identifies a node.\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(matchNode, nameOrCtor, key, typeId) {\n  const data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nameOrCtor === data.nameOrCtor &&\n         typeId === data.typeId &&\n         key == data.key;\n};\n\n\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {NameOrCtorDef} nameOrCtor The name or constructor for the Node.\n * @param {?string=} key The key used to identify the Node..\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n */\nconst alignWithDOM = function(nameOrCtor, key, typeId) {\n  if (currentNode && matches(currentNode, nameOrCtor, key, typeId)) {\n    return;\n  }\n\n  const parentData = getData(currentParent);\n  const currentNodeData = currentNode && getData(currentNode);\n  const keyMap = parentData.keyMap;\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    const keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nameOrCtor, key, typeId)) {\n        node = keyNode;\n      } else if (keyNode !== currentNode) {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nameOrCtor === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nameOrCtor, key, typeId);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nconst removeChild = function(node, child, keyMap) {\n  if (child.parentNode === node) {\n    node.removeChild(child);\n  }\n\n  const key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nconst clearUnvisitedDOM = function() {\n  const node = currentParent;\n  const data = getData(node);\n  const keyMap = data.keyMap;\n  const keyMapValid = data.keyMapValid;\n  let child = node.lastChild;\n  let key;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nconst getNextNode = function() {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  currentNode = getNextNode();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n * @return {!Element} The corresponding Element.\n */\nconst open = function(nameOrCtor, key, typeId) {\n  nextNode();\n  alignWithDOM(nameOrCtor, key, typeId);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst close = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', doc);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nconst currentPointer = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', doc);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nconst skipNode = nextNode;\n\n\n/** */\nexport {\n  text,\n  patchInner,\n  patchOuter,\n  open,\n  close,\n  currentElement,\n  currentPointer,\n  skip,\n  skipNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nconst setStyleValue = function(style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */(value));\n  } else {\n    style[prop] = value;\n  }\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types';\nimport {\n  open,\n  close,\n  text as coreText\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\nimport {\n  createMap,\n  truncateArray\n} from './util';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {!Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * Used to keep track of the previous values when a 2-way diff is ncessary.\n * This object is reused.\n * @const {Object<*>}\n */\nconst prevAttrsMap = createMap();\n\n\n/**\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(nameOrCtor, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = open(nameOrCtor, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (let i = 0; i < statics.length; i += 2) {\n        const name = /** @type {string} */(statics[i]);\n        const value = statics[i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const isNew = !attrsArr.length;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const name = arguments[i];\n    if (isNew) {\n      attrsArr[j] = name;\n    } else if (attrsArr[j] !== name) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, name, value);\n    }\n  }\n\n  /*\n   * Items did not line up exactly as before, need to make sure old items are\n   * removed. This can happen if using conditional logic when declaring\n   * attrs through the elementOpenStart flow or if one element is reused in\n   * the place of another.\n   */\n  if (i < arguments.length || j < attrsArr.length) {\n    const attrsStart = j;\n\n    for (; j < attrsArr.length; j += 2) {\n      prevAttrsMap[attrsArr[j]] = attrsArr[j + 1];\n    }\n\n    for (j = attrsStart; i < arguments.length; i += 2, j += 2) {\n      const name = arguments[i];\n      const value = arguments[i + 1];\n\n      if (prevAttrsMap[name] !== value) {\n        updateAttribute(node, name, value);\n      }\n\n      attrsArr[j] = name;\n      attrsArr[j + 1] = value;\n\n      delete prevAttrsMap[name];\n    }\n\n    if (j < attrsArr.length) {\n      truncateArray(attrsArr, j);\n    }\n\n    /*\n     * At this point, only have attributes that were present before, but have\n     * been removed.\n     */\n    for (const name in prevAttrsMap) {\n      updateAttribute(node, name, undefined);\n      delete prevAttrsMap[name];\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(nameOrCtor, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  truncateArray(argsBuilder, 0);\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(nameOrCtor) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = close();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(nameOrCtor, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr\n};\n"],"names":["hasOwnProperty","Object","prototype","Blank","create","has","map","property","call","createMap","truncateArray","arr","length","pop","NodeData","nameOrCtor","key","typeId","attrsArr","staticsApplied","keyMap","keyMapValid","focused","text","initData","node","data","getData","importNode","isElement","nodeType","nodeName","localName","getAttribute","parentNode","attributes","i","attr","name","value","push","child","firstChild","nextSibling","getNamespaceForTag","tag","parent","namespaceURI","createElement","doc","el","namespace","createElementNS","createText","createTextNode","inAttributes","inSkip","assertInPatch","functionName","context","Error","assertNoUnclosedTags","openElement","root","currentElement","openTags","toLowerCase","join","assertNotInAttributes","assertNotInSkip","assertInAttributes","assertVirtualAttributesClosed","assertCloseMatchesOpenTag","currentNameOrCtor","assertNoChildrenDeclaredYet","previousNode","assertPatchElementNoExtras","startNode","currentNode","expectedNextNode","expectedPrevNode","wasUpdated","previousSibling","wasChanged","wasRemoved","setInAttributes","previous","setInSkip","isDocumentRoot","getAncestry","ancestry","cur","getRootNode","Node","prev","getActiveElement","activeElement","getFocusedPath","contains","moveBefore","referenceNode","insertReferenceNode","next","insertBefore","currentParent","markFocused","focusPath","patchFactory","run","f","fn","prevDoc","prevCurrentNode","prevCurrentParent","previousInAttributes","previousInSkip","ownerDocument","retVal","patchInner","enterNode","exitNode","patchOuter","removeChild","matches","matchNode","alignWithDOM","parentData","currentNodeData","keyNode","replaceChild","clearUnvisitedDOM","lastChild","getNextNode","nextNode","open","close","currentPointer","skip","skipNode","symbols","default","getNamespace","lastIndexOf","applyAttr","removeAttribute","attrNS","setAttributeNS","setAttribute","applyProp","setStyleValue","style","prop","indexOf","setProperty","applyStyle","cssText","elStyle","obj","applyAttributeTyped","type","updateAttribute","mutator","ATTRIBUTES_OFFSET","argsBuilder","prevAttrsMap","elementOpen","statics","var_args","isNew","j","arguments","attrsStart","undefined","elementOpenStart","elementOpenEnd","apply","elementClose","elementVoid","coreText","formatted"],"mappings":"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","sourceRoot":"/source/"}